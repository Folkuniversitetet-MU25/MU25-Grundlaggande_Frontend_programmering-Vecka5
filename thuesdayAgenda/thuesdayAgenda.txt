ğŸ§­ Workshop â€“ ğŸš€ JavaScript: Arrayer, Objekt, Operatorer & Villkor

â° Tid: ca 3h
ğŸ“š Kurs: GrundlÃ¤ggande Frontend-programmering
ğŸ“… Vecka 3 â€“ Tisdag 3 sep

--------------------------------------------------
--------------------------------------------------

ğŸ¯ LektionsmÃ¥l

Efter lektionen ska studenterna kunna:

âœ… Skapa och hantera arrayer (index, length, push/pop)
âœ… Skapa och hantera objekt (keyâ€“value, punktnotation, metoder)
âœ… AnvÃ¤nda aritmetiska, jÃ¤mfÃ¶rande och logiska operatorer
âœ… AnvÃ¤nda if, else if, else fÃ¶r villkor
âœ… FÃ¶rstÃ¥ truthy/falsy i villkorsuttryck

--------------------------------------------------
--------------------------------------------------

ğŸ“ Lektionsplanering (3 timmar)

â€“ PowerPoint & Teori (Slides 27â€“40)

â€“ Code-Along

â€“ SjÃ¤lvstÃ¤ndiga Ã¶vningar

â€“ Reflektion & Q&A

â€“ Sammanfattning & Avslut

- Preview av nÃ¤sta lektion

--------------------------------------------------
--------------------------------------------------

ğŸ“¢ PowerPoint â€“ Talarmanus (Slides 27â€“40)

--------------------------------------------------

ğŸŸ¨ Slide 27 â€“ Operatorer
ğŸ—£ï¸ â€œTre familjer av operatorer vi anvÃ¤nder hela tiden:
â€¢ Aritmetiska: +, -, *, /, % (rÃ¤kna pÃ¥ tal).
â€¢ JÃ¤mfÃ¶relse: ==, ===, !=, !==, <, >, <=, >= (ger alltid true/false).
â€¢ Logiska: && (och), || (eller), ! (inte) fÃ¶r att kombinera villkor.â€

--------------------------------------------------

ğŸŸ¨ Slide 28 â€“ JÃ¤mfÃ¶ra datatyper (==, ===, typeof)
ğŸ—£ï¸ Det finns tvÃ¥ sÃ¤tt: == och ===.

== Ã¤r lite slarvig. Den konverterar datatyper automatiskt, vilket kan ge ovÃ¤ntade resultat. Till exempel: '1' == 1 blir true.

=== Ã¤r mer strikt. Den jÃ¤mfÃ¶r bÃ¥de vÃ¤rde och datatyp. '1' === 1 blir false.

Som regel i professionell kod: anvÃ¤nd alltid ===. DÃ¥ slipper ni konstiga buggar.

Och fÃ¶r att kontrollera vilken datatyp ett vÃ¤rde faktiskt har, anvÃ¤nder vi typeof som returnerar en strÃ¤ng med datatypen: typeof 5 â†’ 'number', typeof '' â†’ 'string', typeof NaN â†’ 'number'.â€
"

--------------------------------------------------

ğŸŸ¨ Slide 29 â€“ Villkor
ğŸ—£ï¸ Villkor ger oss mÃ¶jligheten att fatta beslut i koden.
Ett villkor jÃ¤mfÃ¶r alltid tvÃ¥ vÃ¤rden (om vi inte sÃ¤ger annat) och returnerar antingen true eller false.

Exempel: x < 10. Om x Ã¤r 8 blir resultatet true, annars false.
Testa att kÃ¶ra 1 == '1' â€“ det blir true. Men 1 === '1' blir false.

SÃ¥ villkor Ã¤r egentligen bara frÃ¥gor vi stÃ¤ller till koden: 'Ã„r det hÃ¤r sant eller falskt?'"

Det hÃ¤r anvÃ¤nder vi direkt i if-satser.â€

--------------------------------------------------

ğŸŸ¨ Slide 30 â€“ Val (if / else if / else)
ğŸ—£ï¸ â€œNu kopplar vi ihop villkor med if-satser.
En if-sats sÃ¤ger: 'Om det hÃ¤r Ã¤r sant, gÃ¶r det hÃ¤r. Annars, gÃ¶r nÃ¥got annat.'

Vi kan ocksÃ¥ kedja: else if (...) fÃ¶r fler grenar. PoÃ¤ngen: skriv lÃ¤sbara villkor och gÃ¶r en sak per gren.â€

--------------------------------------------------

ğŸŸ¨ Slide 31 â€“ Array/Listor
ğŸ—£ï¸ â€œEn array Ã¤r en lista av vÃ¤rden, till exempel tal, text eller objekt. Index bÃ¶rjar alltid pÃ¥ 0 â€“ alltsÃ¥ fÃ¶rsta platsen Ã¤r [0]. Om vi fÃ¶rsÃ¶ker komma Ã¥t ett index som inte finns fÃ¥r vi undefined. Vi kan lÃ¤gga till med push() och ta bort med pop(). Ex: let list = [1, 2, true]; list.push(4); â†’ nu innehÃ¥ller listan 4 element. list.pop() tar bort sista elementet och returnerar det.â€

Array.lengt prata om det!

--------------------------------------------------

ğŸŸ¨ Slide 32 â€“ Objekt
ğŸ—£ï¸ â€œEtt objekt Ã¤r en samling nyckelâ€“vÃ¤rde-par. Nyckeln Ã¤r en strÃ¤ng, vÃ¤rdet kan vara vad som helst â€“ text, tal, array, funktion. Vi kommer Ã¥t egenskaper med punktnotation, t.ex. obj.key, eller hakparenteser, t.ex. obj['key']. 

Exempel:
let exampleObject = {
  key: 'value',
  email: 'email@example.com'
};

HÃ¤r kan vi nÃ¥ exampleObject.email fÃ¶r att fÃ¥ vÃ¤rdet.â€

--------------------------------------------------

ğŸŸ¨ Slide 33 â€“ Objekt (metoder & this)
ğŸ—£ï¸ â€œDet vanligaste sÃ¤ttet att skapa objekt Ã¤r med object literals â€“ mÃ¥svingar {}. Om ett vÃ¤rde i objektet Ã¤r en funktion kallas det fÃ¶r en metod. Inuti ett objekt kan vi anvÃ¤nda this fÃ¶r att referera till objektet sjÃ¤lvt. Det gÃ¶r att vi kan nÃ¥ andra egenskaper i samma objekt frÃ¥n en metod.â€

--------------------------------------------------

ğŸŸ¨ Slide 34 â€“ Ã„ndra och kopiera objekt
ğŸ—£ï¸ â€œEn av styrkorna med objekt Ã¤r att vi kan Ã¤ndra och bygga ut dem dynamiskt.
Vi kan Ã¤ndra en egenskap, lÃ¤gga till en ny, eller kopiera objektet.

Exempel:
let o = { title: 'Exempel' }
o.title = 'Modified value'
o.extra = 'New property'

Vi kan ocksÃ¥ kopiera objekt med spread operatorn:
let copy = { ...o }

Nu fÃ¥r vi en ny inte kopia utan en referens av objektet, och Ã¤ndringar i kopian pÃ¥verkar inte originalet."

--------------------------------------------------

ğŸŸ¨ Slide 35 â€“ Scope (introduktion)
ğŸ—£ï¸ â€œScope betyder var en variabel Ã¤r synlig/tillgÃ¤nglig. Vi har global scope (synlig Ã¶verallt), local scope (inuti en funktion), och block scope (inuti mÃ¥svingar). Scope styr hur variabler beter sig och var de kan anvÃ¤ndas.â€

--------------------------------------------------

ğŸŸ¨ Slide 36 â€“ Scope (kodexempel med var)
ğŸ—£ï¸ â€œHÃ¤r har vi ett exempel med var. var har function scope â€“ inte block scope. Det betyder att variabler kan lÃ¤cka ut ur block. FrÃ¥ga till er: vad tror ni skrivs ut hÃ¤r?â€

Vi har en global variabel x, och inuti funktionen skapas en ny x.
Den lokala x skuggar den globala, sÃ¥ nÃ¤r vi skriver ut x utanfÃ¶r funktionen, fÃ¥r vi fortfarande det globala vÃ¤rdet.

Vad hÃ¤nder om vi byter var till let?

--------------------------------------------------

ğŸŸ¨ Slide 37 â€“ Scope (fÃ¶rklaring)
ğŸ—£ï¸ â€œHÃ¤r ser vi svaret: var x = "outside"; gÃ¶r x global. Inuti funktionen skapas en ny x som bara lever dÃ¤r. Det Ã¤r dÃ¤rfÃ¶r vi fÃ¥r â€˜outsideâ€™ i konsolen. Viktigt: let och const har block scope, vilket Ã¤r sÃ¤krare och modernare.â€

--------------------------------------------------

ğŸŸ¨ Slide 38 â€“ Exempel Scope
ğŸ—£ï¸ "HÃ¤r ser vi ett exempel dÃ¤r det faktiskt pÃ¥verkar den globala variabeln.
NÃ¤r vi kÃ¶r y = 20 utan let eller const, sÃ¥ skriver vi Ã¶ver den globala variabeln.

Det Ã¤r dÃ¤rfÃ¶r vi ska undvika var och alltid anvÃ¤nda let eller const.
Det hjÃ¤lper oss att undvika oavsiktliga Ã¶verskrivningar."

Testa med bÃ¥de var och let fÃ¶r att se skillnaden.

--------------------------------------------------

ğŸŸ¨ Slide 39 â€“ Ã–vning (scope & variabeltyper)
ğŸ—£ï¸ â€œVilket nyckelord skulle ni anvÃ¤nda fÃ¶r att deklarera dessa variabler: const eller let? 

Bonus: vilken datatyp tror ni varje variabel har, baserat pÃ¥ namnet? HÃ¤r trÃ¤nar vi bÃ¥de scope och typkÃ¤nsla.â€

Diskutera tvÃ¥ och tvÃ¥, och sedan kÃ¶r vi en snabb genomgÃ¥ng tillsammans."

--------------------------------------------------
--------------------------------------------------

ğŸ’» Code-Along

ğŸ“‚ Mappstruktur:

mondayAgenda/
  â”œâ”€â”€ indexCA.html
  â””â”€â”€ jsCA/scriptCA.js

indexCA.html 
GenomfÃ¶r den koden

scriptCA.js
GenomfÃ¶r den koden

--------------------------------------------------
--------------------------------------------------

ğŸ§  SjÃ¤lvstÃ¤ndiga Ã¶vningar

--------------------------------------------------
--------------------------------------------------

ğŸ“¢ Reflektion & Q&A

- NÃ¤r behÃ¶vs objekt istÃ¤llet fÃ¶r bara arrayer?

--------------------------------------------------

- VarfÃ¶r Ã¤r det viktigt att fÃ¶rstÃ¥ skillnaden mellan == och ===?

--------------------------------------------------

- Har ni stÃ¶tt pÃ¥ situationer dÃ¤r truthy/falsy gav ovÃ¤ntade resultat?

--------------------------------------------------

- Vad kan hÃ¤nda om vi inte fÃ¶rstÃ¥r skillnaden mellan global och lokal variabel?

--------------------------------------------------
--------------------------------------------------